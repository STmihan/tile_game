<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <style>
        body {
            overflow: hidden;
            margin: 0;
            height: 100vh;
            display: flex;
        }
    </style>
</head>
<body>
<canvas></canvas>
<script>class Tile {
    constructor(r, n, s) {
        this.row = r;
        this.num = n;
        this.size = s;

        this.dim = {
            w: tsz,
            h: tsz * this.size,
        };

        this.pos = {
            x: tsz * this.row + this.row * 5,
            y: tls[tls.length - 1] == null ? 0 : tls[tls.length - 1].pos.y - 5 - this.dim.h,
        };
        this.state = 0;
    }

    upd() {
        if (this.pos.y > canvas.height - this.dim.h && this.state !== 1) {
            this.state = -1;
        }
        if (p)
            this.pos.y += spd;

        if (this.state === 0) {
            ctx.fillStyle = "black";
        } else if (this.state === -1) {
            ctx.fillStyle = "red";
        } else if (this.state === 1) {
            ctx.fillStyle = "green";
        }
        ctx.fillRect(
            this.pos.x,
            this.pos.y,
            this.dim.w,
            this.dim.h);
    }

    contain(pos) {
        ctx.fillStyle = "red";
        ctx.fillRect(pos.x - 10, pos.y - 10, 20, 20);
        return pos.x > this.pos.x &&
            pos.x < this.pos.x + this.dim.w &&
            pos.y > this.pos.y &&
            pos.y < this.pos.y + this.dim.h;

    }
}

const canvas = document.querySelector('canvas');
canvas.width = document.querySelector('body').offsetWidth;
canvas.height = document.querySelector('body').offsetHeight;
const ctx = canvas.getContext("2d");

const tsz = (canvas.width - 5 * 2) / 3;
let p = false;
let cn = 0;
let spd = 2;
let tls = [];
let cc = 0;

canvas.onmousedown = (e) => {
    if (!p)
        p = true;
    else
        processClick({x: e.clientX - canvas.getBoundingClientRect().left, y: e.clientY - canvas.getBoundingClientRect().top});
};

const upd = (t) => {
    if (p && tls.some(t => t.state === -1))
        p = false;

    ctx.clearRect(0, 0, canvas.width, canvas.height);
    requestAnimationFrame(upd);
    tls.forEach(tile => tile.upd());
    ctx.font = "32px Comic Sans MS";
    ctx.textAlign = "center";
    ctx.fillStyle = "black";
    ctx.strokeText(cn.toString(), 28, 56, 100);
    ctx.font = "34px Comic Sans MS";
    ctx.fillStyle = "white";
    ctx.fillText(cn.toString(), 28, 56, 100);
    if (t > cc) {
        spd *= 1.2;
        cc += 10000;
    }
    if (tls[Math.floor(tls.length / 2)].pos.y > canvas.height) {
        tls.splice(0, Math.floor(tls.length / 2));
        gt();
    }
};

const processClick = (pos) => {
    let result = false;
    for (let i = 0; i < tls.length; i++) {
        let tile = tls[i];
        if (tile.num === cn) {
            if (tile.contain(pos)) {
                result = true;
            }
        }
    }
    if (result)
        tls.forEach(t => {
            if (t.num === cn && t.contain(pos))
                t.state = 1;
        });
    else {
        tls.forEach(t => {
            if (t.num === cn)
                t.state = -1;
        });
    }
    if (!tls.some(tile => tile.num === cn && tile.state === 0)) ++cn;
};

const rnd = (min, max) => {
    return Math.floor(Math.random() * (max - min)) + min;
};

const gt = () => {
    let max = tls.length + 40;
    let num = tls[tls.length - 1] != null ? tls[tls.length - 1].num + 1 : 0;
    let countThisNum = 0;
    for (let i = tls.length; i < max; i++) {
        let row = rnd(0, 3);
        let size = 1;
        if (countThisNum < 1 && rnd(0, 2) === 0 || countThisNum === 0) {
            countThisNum++;
        } else {
            num++;
            countThisNum = 0;
        }
        tls.push(new Tile(row, num, size));
    }
};

gt();
upd();</script>
</body>
</html>
