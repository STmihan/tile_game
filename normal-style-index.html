<!DOCTYPE html>
<html>
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    body {
      overflow: hidden;
      margin: 0;
      height: 100vh;
      display: flex;
      justify-content: center;
      align-items: center;
    }
  </style>
  <title>Tiles</title>
</head>
<body>
<canvas></canvas>
<script>

  class Tile {
    constructor(row, number, size) {
      this.row = row;
      this.number = number;
      this.size = size;

      this.dimentions = {
        w: tileSize,
        h: tileSize * this.size,
      };

      this.startPosition = {
        x: tileSize * this.row + this.row * offset,
        y: tiles[tiles.length - 1] == null ? 0 : tiles[tiles.length - 1].position.y - offset - this.dimentions.h,
      };

      this.position = this.startPosition;
      this.state = 0;
    }

    draw() {
      if (this.state === 0) {
        ctx.fillStyle = "black";
      } else if (this.state === -1) {
        ctx.fillStyle = "red";
      } else if (this.state === 1) {
        ctx.fillStyle = "green";
      }
      ctx.fillRect(
              this.position.x,
              this.position.y,
              this.dimentions.w,
              this.dimentions.h);
    }

    update() {
      if (this.position.y > canvas.height - this.dimentions.h && this.state !== 1) {
        this.state = -1;
      }
      if (isPlaying)
        this.position.y += speed;


      this.draw();
    }

    contain(pos) {
      ctx.fillStyle = "red";
      ctx.fillRect(pos.x - 10, pos.y - 10, 20, 20);
      return pos.x > this.position.x &&
              pos.x < this.position.x + this.dimentions.w &&
              pos.y > this.position.y &&
              pos.y < this.position.y + this.dimentions.h;

    }
  }

  const canvas = document.querySelector('canvas');
  const body = document.querySelector('body');
  canvas.width = body.offsetWidth;
  canvas.height = body.offsetHeight;
  const ctx = canvas.getContext("2d");

  const offset = 5;
  const tileSize = (canvas.width - offset * 2) / 3;
  const timeMultiplicationPerSecond = 1.2;

  let isPlaying = false;
  let currentNumber = 0;
  let speed = 2;
  let tiles = [];
  let currentCheckpoint = 0;

  canvas.onmousedown = (ev) => {
    if (!isPlaying)
      isPlaying = true;
    else {
      processClick(getCursorPosition(ev));
    }
    canvas.onmouseup = null;
  };

  const loop = (t) => {
    if (isPlaying && tiles.some(t => t.state === -1)) {
      isPlaying = false;
    }
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    requestAnimationFrame(loop);
    tiles.forEach(tile => tile.update());
    ctx.font = "42px Comic Sans MS";
    ctx.textAlign = "center";
    ctx.fillStyle = "black";
    ctx.strokeText(currentNumber.toString(), 28, 56, 100);
    ctx.font = "38px Comic Sans MS";
    ctx.fillStyle = "white";
    ctx.fillText(currentNumber.toString(), 28, 56, 100);
    if (t > currentCheckpoint) {
      speed *= timeMultiplicationPerSecond;
      currentCheckpoint += 10000;
    }
    if (tiles[Math.floor(tiles.length / 2)].position.y > canvas.height) {
      tiles.splice(0, Math.floor(tiles.length / 2));
      generateTiles();
    }
  };

  const getCursorPosition = (event) => {
    const rect = canvas.getBoundingClientRect();
    return {x: event.clientX - rect.left, y: event.clientY - rect.top};
  };

  const processClick = (pos) => {
    let result = false;
    for (let i = 0; i < tiles.length; i++) {
      let tile = tiles[i];
      if (tile.number === currentNumber) {
        if (tile.contain(pos)) {
          result = true;
        }
      }
    }
    if (result)
      tiles.forEach(t => {
        if (t.number === currentNumber && t.contain(pos))
          t.state = 1;
      })
    else {
      tiles.forEach(t => {
        if (t.number === currentNumber)
          t.state = -1;
      })
    }
    if (!tiles.some(tile => tile.number === currentNumber && tile.state === 0)) ++currentNumber;
  };

  const rnd = (min, max) => {
    return Math.floor(Math.random() * (max - min)) + min;
  };

  const generateTiles = () => {
    let max = tiles.length + 40;
    let num = tiles[tiles.length - 1] != null ? tiles[tiles.length - 1].number + 1 : 0;
    let countThisNum = 0;
    for (let i = tiles.length; i < max; i++) {
      let row = rnd(0, 3);
      let size = 1;
      if (countThisNum < 1 && rnd(0, 2) === 0 || countThisNum === 0) {
        countThisNum++;
      } else {
        num++;
        countThisNum = 0;
      }
      tiles.push(new Tile(row, num, size));
    }
  };

  generateTiles();
  loop();

</script>
</body>
</html>
